"use strict";

exports.__esModule = true;
exports.copyTypedArray = exports.copyRegExp = exports.copyObject = exports.copySet = exports.copyMap = exports.createCopyIterable = exports.copyBuffer = exports.copyArrayBuffer = exports.copyArray = exports.shouldObjectBeCopied = exports.isObjectCopyable = exports.getRegExpFlags = exports.getObjectToCopy = exports.getPrototype = exports.getProto = exports.getNewCache = void 0;

var _constants = require("./constants");

var create = Object.create,
    getKeys = Object.keys,
    getSymbols = Object.getOwnPropertySymbols,
    getPrototypeOf = Object.getPrototypeOf;
var propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

var getNewCache = function getNewCache() {
  return _constants.HAS_WEAKSET_SUPPORT ? new WeakSet() : create({
    _values: [],
    add: function add(value) {
      this._values.push(value);
    },
    has: function has(value) {
      return !!~this._values.indexOf(value);
    }
  });
};

exports.getNewCache = getNewCache;

var getProto = function getProto(object) {
  return object ? object.__proto__ : null;
};

exports.getProto = getProto;

var getPrototype = function () {
  try {
    var object = {};

    if (object.__proto__ !== void 0) {
      return getProto;
    }

    throw new Error();
  } catch (error) {
    return getPrototypeOf;
  }
}();

exports.getPrototype = getPrototype;

var getObjectToCopy = function getObjectToCopy(object, realm, isPlainObject) {
  if (isPlainObject) {
    var prototype = getPrototype(object);
    return prototype === realm.Object.prototype ? {} : create(prototype);
  }

  return object.constructor ? new object.constructor() : create(null);
};

exports.getObjectToCopy = getObjectToCopy;

var getRegExpFlags = function getRegExpFlags(regExp) {
  var flags = '';

  if (regExp.global) {
    flags += 'g';
  }

  if (regExp.ignoreCase) {
    flags += 'i';
  }

  if (regExp.multiline) {
    flags += 'm';
  }

  if (regExp.unicode) {
    flags += 'u';
  }

  if (regExp.sticky) {
    flags += 'y';
  }

  return flags;
};

exports.getRegExpFlags = getRegExpFlags;

var isObjectCopyable = function isObjectCopyable(object, cache) {
  return typeof object === 'object' && object !== null && !cache.has(object);
};

exports.isObjectCopyable = isObjectCopyable;

var shouldObjectBeCopied = function shouldObjectBeCopied(object, realm) {
  return typeof object.then !== 'function' && !(object instanceof realm.Error) && !(realm.WeakMap && object instanceof realm.WeakMap) && !(realm.WeakSet && object instanceof realm.WeakSet);
};

exports.shouldObjectBeCopied = shouldObjectBeCopied;

var copyArray = function copyArray(array, copy, realm) {
  var newArray = new array.constructor();

  for (var index = 0; index < array.length; index++) {
    newArray[index] = copy(array[index], realm);
  }

  return newArray;
};

exports.copyArray = copyArray;

var copyArrayBuffer = function copyArrayBuffer(arrayBuffer) {
  return arrayBuffer.slice(0);
};

exports.copyArrayBuffer = copyArrayBuffer;

var copyBuffer = function copyBuffer(buffer, realm) {
  var newBuffer = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(buffer.length) : new realm.Buffer(buffer.length);
  buffer.copy(newBuffer);
  return newBuffer;
};

exports.copyBuffer = copyBuffer;

var createCopyIterable = function createCopyIterable(assignmentHandler) {
  return function (iterable, copy, realm) {
    var newIterable = new iterable.constructor();
    iterable.forEach(assignmentHandler(newIterable, copy, realm));
    return newIterable;
  };
};

exports.createCopyIterable = createCopyIterable;
var copyMap = createCopyIterable(function (iterable, copy, realm) {
  return function (value, key) {
    return iterable.set(key, copy(value, realm));
  };
});
exports.copyMap = copyMap;
var copySet = createCopyIterable(function (iterable, copy, realm) {
  return function (value) {
    return iterable.add(copy(value, realm));
  };
});
exports.copySet = copySet;

var copyObject = function copyObject(object, copy, realm, isPlainObject) {
  var newObject = getObjectToCopy(object, realm, isPlainObject);
  var keys = getKeys(object);

  if (keys.length) {
    var key;

    for (var index = 0; index < keys.length; index++) {
      key = keys[index];
      newObject[key] = copy(object[key], realm);
    }
  }

  if (_constants.HAS_PROPERTY_SYMBOL_SUPPORT) {
    var symbols = getSymbols(object);

    if (symbols.length) {
      var symbol;

      for (var _index = 0; _index < symbols.length; _index++) {
        symbol = symbols[_index];

        if (propertyIsEnumerable.call(object, symbol)) {
          newObject[symbol] = copy(object[symbol], realm);
        }
      }
    }
  }

  return newObject;
};

exports.copyObject = copyObject;

var copyRegExp = function copyRegExp(regExp, realm) {
  var newRegExp = new realm.RegExp(regExp.source, _constants.HAS_FLAGS_SUPPORT ? regExp.flags : getRegExpFlags(regExp));
  newRegExp.lastIndex = regExp.lastIndex;
  return newRegExp;
};

exports.copyRegExp = copyRegExp;

var copyTypedArray = function copyTypedArray(typedArray) {
  return new typedArray.constructor(copyArrayBuffer(typedArray.buffer));
};

exports.copyTypedArray = copyTypedArray;